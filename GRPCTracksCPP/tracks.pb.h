// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tracks.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tracks_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tracks_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tracks_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tracks_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tracks_2eproto;
namespace tracks {
class HelloReply;
struct HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class ProtoCoord;
struct ProtoCoordDefaultTypeInternal;
extern ProtoCoordDefaultTypeInternal _ProtoCoord_default_instance_;
class ProtoFig;
struct ProtoFigDefaultTypeInternal;
extern ProtoFigDefaultTypeInternal _ProtoFig_default_instance_;
class ProtoFigures;
struct ProtoFiguresDefaultTypeInternal;
extern ProtoFiguresDefaultTypeInternal _ProtoFigures_default_instance_;
class ProtoGeometry;
struct ProtoGeometryDefaultTypeInternal;
extern ProtoGeometryDefaultTypeInternal _ProtoGeometry_default_instance_;
class ProtoObjExtraProperty;
struct ProtoObjExtraPropertyDefaultTypeInternal;
extern ProtoObjExtraPropertyDefaultTypeInternal _ProtoObjExtraProperty_default_instance_;
}  // namespace tracks
PROTOBUF_NAMESPACE_OPEN
template<> ::tracks::HelloReply* Arena::CreateMaybeMessage<::tracks::HelloReply>(Arena*);
template<> ::tracks::HelloRequest* Arena::CreateMaybeMessage<::tracks::HelloRequest>(Arena*);
template<> ::tracks::ProtoCoord* Arena::CreateMaybeMessage<::tracks::ProtoCoord>(Arena*);
template<> ::tracks::ProtoFig* Arena::CreateMaybeMessage<::tracks::ProtoFig>(Arena*);
template<> ::tracks::ProtoFigures* Arena::CreateMaybeMessage<::tracks::ProtoFigures>(Arena*);
template<> ::tracks::ProtoGeometry* Arena::CreateMaybeMessage<::tracks::ProtoGeometry>(Arena*);
template<> ::tracks::ProtoObjExtraProperty* Arena::CreateMaybeMessage<::tracks::ProtoObjExtraProperty>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tracks {

// ===================================================================

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:tracks.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class HelloReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.HelloReply) */ {
 public:
  inline HelloReply() : HelloReply(nullptr) {}
  ~HelloReply() override;
  explicit PROTOBUF_CONSTEXPR HelloReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloReply& from) {
    HelloReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.HelloReply";
  }
  protected:
  explicit HelloReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tracks.HelloReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class ProtoObjExtraProperty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.ProtoObjExtraProperty) */ {
 public:
  inline ProtoObjExtraProperty() : ProtoObjExtraProperty(nullptr) {}
  ~ProtoObjExtraProperty() override;
  explicit PROTOBUF_CONSTEXPR ProtoObjExtraProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoObjExtraProperty(const ProtoObjExtraProperty& from);
  ProtoObjExtraProperty(ProtoObjExtraProperty&& from) noexcept
    : ProtoObjExtraProperty() {
    *this = ::std::move(from);
  }

  inline ProtoObjExtraProperty& operator=(const ProtoObjExtraProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoObjExtraProperty& operator=(ProtoObjExtraProperty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoObjExtraProperty& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoObjExtraProperty* internal_default_instance() {
    return reinterpret_cast<const ProtoObjExtraProperty*>(
               &_ProtoObjExtraProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProtoObjExtraProperty& a, ProtoObjExtraProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoObjExtraProperty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoObjExtraProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoObjExtraProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoObjExtraProperty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoObjExtraProperty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoObjExtraProperty& from) {
    ProtoObjExtraProperty::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoObjExtraProperty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.ProtoObjExtraProperty";
  }
  protected:
  explicit ProtoObjExtraProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrValFieldNumber = 1,
    kPropNameFieldNumber = 2,
    kVisualTypeFieldNumber = 3,
  };
  // string str_val = 1;
  void clear_str_val();
  const std::string& str_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_val();
  PROTOBUF_NODISCARD std::string* release_str_val();
  void set_allocated_str_val(std::string* str_val);
  private:
  const std::string& _internal_str_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_val(const std::string& value);
  std::string* _internal_mutable_str_val();
  public:

  // string prop_name = 2;
  void clear_prop_name();
  const std::string& prop_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prop_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prop_name();
  PROTOBUF_NODISCARD std::string* release_prop_name();
  void set_allocated_prop_name(std::string* prop_name);
  private:
  const std::string& _internal_prop_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prop_name(const std::string& value);
  std::string* _internal_mutable_prop_name();
  public:

  // string visual_type = 3;
  void clear_visual_type();
  const std::string& visual_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_visual_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_visual_type();
  PROTOBUF_NODISCARD std::string* release_visual_type();
  void set_allocated_visual_type(std::string* visual_type);
  private:
  const std::string& _internal_visual_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_visual_type(const std::string& value);
  std::string* _internal_mutable_visual_type();
  public:

  // @@protoc_insertion_point(class_scope:tracks.ProtoObjExtraProperty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prop_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr visual_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class ProtoCoord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.ProtoCoord) */ {
 public:
  inline ProtoCoord() : ProtoCoord(nullptr) {}
  ~ProtoCoord() override;
  explicit PROTOBUF_CONSTEXPR ProtoCoord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoCoord(const ProtoCoord& from);
  ProtoCoord(ProtoCoord&& from) noexcept
    : ProtoCoord() {
    *this = ::std::move(from);
  }

  inline ProtoCoord& operator=(const ProtoCoord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoCoord& operator=(ProtoCoord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoCoord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoCoord* internal_default_instance() {
    return reinterpret_cast<const ProtoCoord*>(
               &_ProtoCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProtoCoord& a, ProtoCoord& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoCoord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoCoord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoCoord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoCoord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoCoord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoCoord& from) {
    ProtoCoord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoCoord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.ProtoCoord";
  }
  protected:
  explicit ProtoCoord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // @@protoc_insertion_point(class_scope:tracks.ProtoCoord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double lat_;
    double lon_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class ProtoGeometry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.ProtoGeometry) */ {
 public:
  inline ProtoGeometry() : ProtoGeometry(nullptr) {}
  ~ProtoGeometry() override;
  explicit PROTOBUF_CONSTEXPR ProtoGeometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoGeometry(const ProtoGeometry& from);
  ProtoGeometry(ProtoGeometry&& from) noexcept
    : ProtoGeometry() {
    *this = ::std::move(from);
  }

  inline ProtoGeometry& operator=(const ProtoGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoGeometry& operator=(ProtoGeometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoGeometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoGeometry* internal_default_instance() {
    return reinterpret_cast<const ProtoGeometry*>(
               &_ProtoGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProtoGeometry& a, ProtoGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoGeometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoGeometry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoGeometry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoGeometry& from) {
    ProtoGeometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoGeometry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.ProtoGeometry";
  }
  protected:
  explicit ProtoGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .tracks.ProtoCoord coord = 1;
  int coord_size() const;
  private:
  int _internal_coord_size() const;
  public:
  void clear_coord();
  ::tracks::ProtoCoord* mutable_coord(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoCoord >*
      mutable_coord();
  private:
  const ::tracks::ProtoCoord& _internal_coord(int index) const;
  ::tracks::ProtoCoord* _internal_add_coord();
  public:
  const ::tracks::ProtoCoord& coord(int index) const;
  ::tracks::ProtoCoord* add_coord();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoCoord >&
      coord() const;

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:tracks.ProtoGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoCoord > coord_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class ProtoFig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.ProtoFig) */ {
 public:
  inline ProtoFig() : ProtoFig(nullptr) {}
  ~ProtoFig() override;
  explicit PROTOBUF_CONSTEXPR ProtoFig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoFig(const ProtoFig& from);
  ProtoFig(ProtoFig&& from) noexcept
    : ProtoFig() {
    *this = ::std::move(from);
  }

  inline ProtoFig& operator=(const ProtoFig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoFig& operator=(ProtoFig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoFig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoFig* internal_default_instance() {
    return reinterpret_cast<const ProtoFig*>(
               &_ProtoFig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProtoFig& a, ProtoFig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoFig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoFig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoFig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoFig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoFig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoFig& from) {
    ProtoFig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoFig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.ProtoFig";
  }
  protected:
  explicit ProtoFig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraPropsFieldNumber = 4,
    kZoomLevelFieldNumber = 3,
    kIdFieldNumber = 5,
    kParentIdFieldNumber = 6,
    kNameFieldNumber = 7,
    kExternalTypeFieldNumber = 8,
    kGeometryFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // repeated .tracks.ProtoObjExtraProperty extra_props = 4;
  int extra_props_size() const;
  private:
  int _internal_extra_props_size() const;
  public:
  void clear_extra_props();
  ::tracks::ProtoObjExtraProperty* mutable_extra_props(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoObjExtraProperty >*
      mutable_extra_props();
  private:
  const ::tracks::ProtoObjExtraProperty& _internal_extra_props(int index) const;
  ::tracks::ProtoObjExtraProperty* _internal_add_extra_props();
  public:
  const ::tracks::ProtoObjExtraProperty& extra_props(int index) const;
  ::tracks::ProtoObjExtraProperty* add_extra_props();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoObjExtraProperty >&
      extra_props() const;

  // optional string zoom_level = 3;
  bool has_zoom_level() const;
  private:
  bool _internal_has_zoom_level() const;
  public:
  void clear_zoom_level();
  const std::string& zoom_level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_zoom_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_zoom_level();
  PROTOBUF_NODISCARD std::string* release_zoom_level();
  void set_allocated_zoom_level(std::string* zoom_level);
  private:
  const std::string& _internal_zoom_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zoom_level(const std::string& value);
  std::string* _internal_mutable_zoom_level();
  public:

  // string id = 5;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string parent_id = 6;
  bool has_parent_id() const;
  private:
  bool _internal_has_parent_id() const;
  public:
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // string name = 7;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string external_type = 8;
  bool has_external_type() const;
  private:
  bool _internal_has_external_type() const;
  public:
  void clear_external_type();
  const std::string& external_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_external_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_external_type();
  PROTOBUF_NODISCARD std::string* release_external_type();
  void set_allocated_external_type(std::string* external_type);
  private:
  const std::string& _internal_external_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_type(const std::string& value);
  std::string* _internal_mutable_external_type();
  public:

  // .tracks.ProtoGeometry geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::tracks::ProtoGeometry& geometry() const;
  PROTOBUF_NODISCARD ::tracks::ProtoGeometry* release_geometry();
  ::tracks::ProtoGeometry* mutable_geometry();
  void set_allocated_geometry(::tracks::ProtoGeometry* geometry);
  private:
  const ::tracks::ProtoGeometry& _internal_geometry() const;
  ::tracks::ProtoGeometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::tracks::ProtoGeometry* geometry);
  ::tracks::ProtoGeometry* unsafe_arena_release_geometry();

  // optional double radius = 2;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:tracks.ProtoFig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoObjExtraProperty > extra_props_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zoom_level_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr external_type_;
    ::tracks::ProtoGeometry* geometry_;
    double radius_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// -------------------------------------------------------------------

class ProtoFigures final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tracks.ProtoFigures) */ {
 public:
  inline ProtoFigures() : ProtoFigures(nullptr) {}
  ~ProtoFigures() override;
  explicit PROTOBUF_CONSTEXPR ProtoFigures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoFigures(const ProtoFigures& from);
  ProtoFigures(ProtoFigures&& from) noexcept
    : ProtoFigures() {
    *this = ::std::move(from);
  }

  inline ProtoFigures& operator=(const ProtoFigures& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoFigures& operator=(ProtoFigures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoFigures& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoFigures* internal_default_instance() {
    return reinterpret_cast<const ProtoFigures*>(
               &_ProtoFigures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProtoFigures& a, ProtoFigures& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoFigures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoFigures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoFigures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoFigures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoFigures& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoFigures& from) {
    ProtoFigures::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoFigures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tracks.ProtoFigures";
  }
  protected:
  explicit ProtoFigures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFigsFieldNumber = 1,
    kAddTracksFieldNumber = 2,
  };
  // repeated .tracks.ProtoFig figs = 1;
  int figs_size() const;
  private:
  int _internal_figs_size() const;
  public:
  void clear_figs();
  ::tracks::ProtoFig* mutable_figs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoFig >*
      mutable_figs();
  private:
  const ::tracks::ProtoFig& _internal_figs(int index) const;
  ::tracks::ProtoFig* _internal_add_figs();
  public:
  const ::tracks::ProtoFig& figs(int index) const;
  ::tracks::ProtoFig* add_figs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoFig >&
      figs() const;

  // optional bool add_tracks = 2;
  bool has_add_tracks() const;
  private:
  bool _internal_has_add_tracks() const;
  public:
  void clear_add_tracks();
  bool add_tracks() const;
  void set_add_tracks(bool value);
  private:
  bool _internal_add_tracks() const;
  void _internal_set_add_tracks(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tracks.ProtoFigures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoFig > figs_;
    bool add_tracks_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tracks_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:tracks.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tracks.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:tracks.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:tracks.HelloReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:tracks.HelloReply.message)
  return _s;
}
inline const std::string& HelloReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HelloReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:tracks.HelloReply.message)
  return _impl_.message_.Release();
}
inline void HelloReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.HelloReply.message)
}

// -------------------------------------------------------------------

// ProtoObjExtraProperty

// string str_val = 1;
inline void ProtoObjExtraProperty::clear_str_val() {
  _impl_.str_val_.ClearToEmpty();
}
inline const std::string& ProtoObjExtraProperty::str_val() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoObjExtraProperty.str_val)
  return _internal_str_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoObjExtraProperty::set_str_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.str_val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoObjExtraProperty.str_val)
}
inline std::string* ProtoObjExtraProperty::mutable_str_val() {
  std::string* _s = _internal_mutable_str_val();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoObjExtraProperty.str_val)
  return _s;
}
inline const std::string& ProtoObjExtraProperty::_internal_str_val() const {
  return _impl_.str_val_.Get();
}
inline void ProtoObjExtraProperty::_internal_set_str_val(const std::string& value) {
  
  _impl_.str_val_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::_internal_mutable_str_val() {
  
  return _impl_.str_val_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::release_str_val() {
  // @@protoc_insertion_point(field_release:tracks.ProtoObjExtraProperty.str_val)
  return _impl_.str_val_.Release();
}
inline void ProtoObjExtraProperty::set_allocated_str_val(std::string* str_val) {
  if (str_val != nullptr) {
    
  } else {
    
  }
  _impl_.str_val_.SetAllocated(str_val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_val_.IsDefault()) {
    _impl_.str_val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoObjExtraProperty.str_val)
}

// string prop_name = 2;
inline void ProtoObjExtraProperty::clear_prop_name() {
  _impl_.prop_name_.ClearToEmpty();
}
inline const std::string& ProtoObjExtraProperty::prop_name() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoObjExtraProperty.prop_name)
  return _internal_prop_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoObjExtraProperty::set_prop_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prop_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoObjExtraProperty.prop_name)
}
inline std::string* ProtoObjExtraProperty::mutable_prop_name() {
  std::string* _s = _internal_mutable_prop_name();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoObjExtraProperty.prop_name)
  return _s;
}
inline const std::string& ProtoObjExtraProperty::_internal_prop_name() const {
  return _impl_.prop_name_.Get();
}
inline void ProtoObjExtraProperty::_internal_set_prop_name(const std::string& value) {
  
  _impl_.prop_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::_internal_mutable_prop_name() {
  
  return _impl_.prop_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::release_prop_name() {
  // @@protoc_insertion_point(field_release:tracks.ProtoObjExtraProperty.prop_name)
  return _impl_.prop_name_.Release();
}
inline void ProtoObjExtraProperty::set_allocated_prop_name(std::string* prop_name) {
  if (prop_name != nullptr) {
    
  } else {
    
  }
  _impl_.prop_name_.SetAllocated(prop_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prop_name_.IsDefault()) {
    _impl_.prop_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoObjExtraProperty.prop_name)
}

// string visual_type = 3;
inline void ProtoObjExtraProperty::clear_visual_type() {
  _impl_.visual_type_.ClearToEmpty();
}
inline const std::string& ProtoObjExtraProperty::visual_type() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoObjExtraProperty.visual_type)
  return _internal_visual_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoObjExtraProperty::set_visual_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.visual_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoObjExtraProperty.visual_type)
}
inline std::string* ProtoObjExtraProperty::mutable_visual_type() {
  std::string* _s = _internal_mutable_visual_type();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoObjExtraProperty.visual_type)
  return _s;
}
inline const std::string& ProtoObjExtraProperty::_internal_visual_type() const {
  return _impl_.visual_type_.Get();
}
inline void ProtoObjExtraProperty::_internal_set_visual_type(const std::string& value) {
  
  _impl_.visual_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::_internal_mutable_visual_type() {
  
  return _impl_.visual_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoObjExtraProperty::release_visual_type() {
  // @@protoc_insertion_point(field_release:tracks.ProtoObjExtraProperty.visual_type)
  return _impl_.visual_type_.Release();
}
inline void ProtoObjExtraProperty::set_allocated_visual_type(std::string* visual_type) {
  if (visual_type != nullptr) {
    
  } else {
    
  }
  _impl_.visual_type_.SetAllocated(visual_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.visual_type_.IsDefault()) {
    _impl_.visual_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoObjExtraProperty.visual_type)
}

// -------------------------------------------------------------------

// ProtoCoord

// double lat = 1;
inline void ProtoCoord::clear_lat() {
  _impl_.lat_ = 0;
}
inline double ProtoCoord::_internal_lat() const {
  return _impl_.lat_;
}
inline double ProtoCoord::lat() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoCoord.lat)
  return _internal_lat();
}
inline void ProtoCoord::_internal_set_lat(double value) {
  
  _impl_.lat_ = value;
}
inline void ProtoCoord::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:tracks.ProtoCoord.lat)
}

// double lon = 2;
inline void ProtoCoord::clear_lon() {
  _impl_.lon_ = 0;
}
inline double ProtoCoord::_internal_lon() const {
  return _impl_.lon_;
}
inline double ProtoCoord::lon() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoCoord.lon)
  return _internal_lon();
}
inline void ProtoCoord::_internal_set_lon(double value) {
  
  _impl_.lon_ = value;
}
inline void ProtoCoord::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:tracks.ProtoCoord.lon)
}

// -------------------------------------------------------------------

// ProtoGeometry

// repeated .tracks.ProtoCoord coord = 1;
inline int ProtoGeometry::_internal_coord_size() const {
  return _impl_.coord_.size();
}
inline int ProtoGeometry::coord_size() const {
  return _internal_coord_size();
}
inline void ProtoGeometry::clear_coord() {
  _impl_.coord_.Clear();
}
inline ::tracks::ProtoCoord* ProtoGeometry::mutable_coord(int index) {
  // @@protoc_insertion_point(field_mutable:tracks.ProtoGeometry.coord)
  return _impl_.coord_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoCoord >*
ProtoGeometry::mutable_coord() {
  // @@protoc_insertion_point(field_mutable_list:tracks.ProtoGeometry.coord)
  return &_impl_.coord_;
}
inline const ::tracks::ProtoCoord& ProtoGeometry::_internal_coord(int index) const {
  return _impl_.coord_.Get(index);
}
inline const ::tracks::ProtoCoord& ProtoGeometry::coord(int index) const {
  // @@protoc_insertion_point(field_get:tracks.ProtoGeometry.coord)
  return _internal_coord(index);
}
inline ::tracks::ProtoCoord* ProtoGeometry::_internal_add_coord() {
  return _impl_.coord_.Add();
}
inline ::tracks::ProtoCoord* ProtoGeometry::add_coord() {
  ::tracks::ProtoCoord* _add = _internal_add_coord();
  // @@protoc_insertion_point(field_add:tracks.ProtoGeometry.coord)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoCoord >&
ProtoGeometry::coord() const {
  // @@protoc_insertion_point(field_list:tracks.ProtoGeometry.coord)
  return _impl_.coord_;
}

// string type = 2;
inline void ProtoGeometry::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ProtoGeometry::type() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoGeometry.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoGeometry::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoGeometry.type)
}
inline std::string* ProtoGeometry::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoGeometry.type)
  return _s;
}
inline const std::string& ProtoGeometry::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ProtoGeometry::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoGeometry::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoGeometry::release_type() {
  // @@protoc_insertion_point(field_release:tracks.ProtoGeometry.type)
  return _impl_.type_.Release();
}
inline void ProtoGeometry::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoGeometry.type)
}

// -------------------------------------------------------------------

// ProtoFig

// .tracks.ProtoGeometry geometry = 1;
inline bool ProtoFig::_internal_has_geometry() const {
  return this != internal_default_instance() && _impl_.geometry_ != nullptr;
}
inline bool ProtoFig::has_geometry() const {
  return _internal_has_geometry();
}
inline void ProtoFig::clear_geometry() {
  if (GetArenaForAllocation() == nullptr && _impl_.geometry_ != nullptr) {
    delete _impl_.geometry_;
  }
  _impl_.geometry_ = nullptr;
}
inline const ::tracks::ProtoGeometry& ProtoFig::_internal_geometry() const {
  const ::tracks::ProtoGeometry* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::tracks::ProtoGeometry&>(
      ::tracks::_ProtoGeometry_default_instance_);
}
inline const ::tracks::ProtoGeometry& ProtoFig::geometry() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.geometry)
  return _internal_geometry();
}
inline void ProtoFig::unsafe_arena_set_allocated_geometry(
    ::tracks::ProtoGeometry* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tracks.ProtoFig.geometry)
}
inline ::tracks::ProtoGeometry* ProtoFig::release_geometry() {
  
  ::tracks::ProtoGeometry* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tracks::ProtoGeometry* ProtoFig::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.geometry)
  
  ::tracks::ProtoGeometry* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::tracks::ProtoGeometry* ProtoFig::_internal_mutable_geometry() {
  
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::tracks::ProtoGeometry>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::tracks::ProtoGeometry* ProtoFig::mutable_geometry() {
  ::tracks::ProtoGeometry* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.geometry)
  return _msg;
}
inline void ProtoFig::set_allocated_geometry(::tracks::ProtoGeometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.geometry)
}

// optional double radius = 2;
inline bool ProtoFig::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProtoFig::has_radius() const {
  return _internal_has_radius();
}
inline void ProtoFig::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ProtoFig::_internal_radius() const {
  return _impl_.radius_;
}
inline double ProtoFig::radius() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.radius)
  return _internal_radius();
}
inline void ProtoFig::_internal_set_radius(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.radius_ = value;
}
inline void ProtoFig::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.radius)
}

// optional string zoom_level = 3;
inline bool ProtoFig::_internal_has_zoom_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProtoFig::has_zoom_level() const {
  return _internal_has_zoom_level();
}
inline void ProtoFig::clear_zoom_level() {
  _impl_.zoom_level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProtoFig::zoom_level() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.zoom_level)
  return _internal_zoom_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoFig::set_zoom_level(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.zoom_level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.zoom_level)
}
inline std::string* ProtoFig::mutable_zoom_level() {
  std::string* _s = _internal_mutable_zoom_level();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.zoom_level)
  return _s;
}
inline const std::string& ProtoFig::_internal_zoom_level() const {
  return _impl_.zoom_level_.Get();
}
inline void ProtoFig::_internal_set_zoom_level(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.zoom_level_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoFig::_internal_mutable_zoom_level() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.zoom_level_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoFig::release_zoom_level() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.zoom_level)
  if (!_internal_has_zoom_level()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.zoom_level_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zoom_level_.IsDefault()) {
    _impl_.zoom_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProtoFig::set_allocated_zoom_level(std::string* zoom_level) {
  if (zoom_level != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.zoom_level_.SetAllocated(zoom_level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.zoom_level_.IsDefault()) {
    _impl_.zoom_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.zoom_level)
}

// repeated .tracks.ProtoObjExtraProperty extra_props = 4;
inline int ProtoFig::_internal_extra_props_size() const {
  return _impl_.extra_props_.size();
}
inline int ProtoFig::extra_props_size() const {
  return _internal_extra_props_size();
}
inline void ProtoFig::clear_extra_props() {
  _impl_.extra_props_.Clear();
}
inline ::tracks::ProtoObjExtraProperty* ProtoFig::mutable_extra_props(int index) {
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.extra_props)
  return _impl_.extra_props_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoObjExtraProperty >*
ProtoFig::mutable_extra_props() {
  // @@protoc_insertion_point(field_mutable_list:tracks.ProtoFig.extra_props)
  return &_impl_.extra_props_;
}
inline const ::tracks::ProtoObjExtraProperty& ProtoFig::_internal_extra_props(int index) const {
  return _impl_.extra_props_.Get(index);
}
inline const ::tracks::ProtoObjExtraProperty& ProtoFig::extra_props(int index) const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.extra_props)
  return _internal_extra_props(index);
}
inline ::tracks::ProtoObjExtraProperty* ProtoFig::_internal_add_extra_props() {
  return _impl_.extra_props_.Add();
}
inline ::tracks::ProtoObjExtraProperty* ProtoFig::add_extra_props() {
  ::tracks::ProtoObjExtraProperty* _add = _internal_add_extra_props();
  // @@protoc_insertion_point(field_add:tracks.ProtoFig.extra_props)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoObjExtraProperty >&
ProtoFig::extra_props() const {
  // @@protoc_insertion_point(field_list:tracks.ProtoFig.extra_props)
  return _impl_.extra_props_;
}

// string id = 5;
inline void ProtoFig::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ProtoFig::id() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoFig::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.id)
}
inline std::string* ProtoFig::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.id)
  return _s;
}
inline const std::string& ProtoFig::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ProtoFig::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoFig::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoFig::release_id() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.id)
  return _impl_.id_.Release();
}
inline void ProtoFig::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.id)
}

// optional string parent_id = 6;
inline bool ProtoFig::_internal_has_parent_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProtoFig::has_parent_id() const {
  return _internal_has_parent_id();
}
inline void ProtoFig::clear_parent_id() {
  _impl_.parent_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProtoFig::parent_id() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoFig::set_parent_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.parent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.parent_id)
}
inline std::string* ProtoFig::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.parent_id)
  return _s;
}
inline const std::string& ProtoFig::_internal_parent_id() const {
  return _impl_.parent_id_.Get();
}
inline void ProtoFig::_internal_set_parent_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoFig::_internal_mutable_parent_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.parent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoFig::release_parent_id() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.parent_id)
  if (!_internal_has_parent_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.parent_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_id_.IsDefault()) {
    _impl_.parent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProtoFig::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_id_.SetAllocated(parent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_id_.IsDefault()) {
    _impl_.parent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.parent_id)
}

// string name = 7;
inline void ProtoFig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProtoFig::name() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoFig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.name)
}
inline std::string* ProtoFig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.name)
  return _s;
}
inline const std::string& ProtoFig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ProtoFig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoFig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoFig::release_name() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.name)
  return _impl_.name_.Release();
}
inline void ProtoFig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.name)
}

// optional string external_type = 8;
inline bool ProtoFig::_internal_has_external_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProtoFig::has_external_type() const {
  return _internal_has_external_type();
}
inline void ProtoFig::clear_external_type() {
  _impl_.external_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProtoFig::external_type() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFig.external_type)
  return _internal_external_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoFig::set_external_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.external_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tracks.ProtoFig.external_type)
}
inline std::string* ProtoFig::mutable_external_type() {
  std::string* _s = _internal_mutable_external_type();
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFig.external_type)
  return _s;
}
inline const std::string& ProtoFig::_internal_external_type() const {
  return _impl_.external_type_.Get();
}
inline void ProtoFig::_internal_set_external_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.external_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoFig::_internal_mutable_external_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.external_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoFig::release_external_type() {
  // @@protoc_insertion_point(field_release:tracks.ProtoFig.external_type)
  if (!_internal_has_external_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.external_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_type_.IsDefault()) {
    _impl_.external_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProtoFig::set_allocated_external_type(std::string* external_type) {
  if (external_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.external_type_.SetAllocated(external_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.external_type_.IsDefault()) {
    _impl_.external_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tracks.ProtoFig.external_type)
}

// -------------------------------------------------------------------

// ProtoFigures

// repeated .tracks.ProtoFig figs = 1;
inline int ProtoFigures::_internal_figs_size() const {
  return _impl_.figs_.size();
}
inline int ProtoFigures::figs_size() const {
  return _internal_figs_size();
}
inline void ProtoFigures::clear_figs() {
  _impl_.figs_.Clear();
}
inline ::tracks::ProtoFig* ProtoFigures::mutable_figs(int index) {
  // @@protoc_insertion_point(field_mutable:tracks.ProtoFigures.figs)
  return _impl_.figs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoFig >*
ProtoFigures::mutable_figs() {
  // @@protoc_insertion_point(field_mutable_list:tracks.ProtoFigures.figs)
  return &_impl_.figs_;
}
inline const ::tracks::ProtoFig& ProtoFigures::_internal_figs(int index) const {
  return _impl_.figs_.Get(index);
}
inline const ::tracks::ProtoFig& ProtoFigures::figs(int index) const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFigures.figs)
  return _internal_figs(index);
}
inline ::tracks::ProtoFig* ProtoFigures::_internal_add_figs() {
  return _impl_.figs_.Add();
}
inline ::tracks::ProtoFig* ProtoFigures::add_figs() {
  ::tracks::ProtoFig* _add = _internal_add_figs();
  // @@protoc_insertion_point(field_add:tracks.ProtoFigures.figs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tracks::ProtoFig >&
ProtoFigures::figs() const {
  // @@protoc_insertion_point(field_list:tracks.ProtoFigures.figs)
  return _impl_.figs_;
}

// optional bool add_tracks = 2;
inline bool ProtoFigures::_internal_has_add_tracks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProtoFigures::has_add_tracks() const {
  return _internal_has_add_tracks();
}
inline void ProtoFigures::clear_add_tracks() {
  _impl_.add_tracks_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ProtoFigures::_internal_add_tracks() const {
  return _impl_.add_tracks_;
}
inline bool ProtoFigures::add_tracks() const {
  // @@protoc_insertion_point(field_get:tracks.ProtoFigures.add_tracks)
  return _internal_add_tracks();
}
inline void ProtoFigures::_internal_set_add_tracks(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.add_tracks_ = value;
}
inline void ProtoFigures::set_add_tracks(bool value) {
  _internal_set_add_tracks(value);
  // @@protoc_insertion_point(field_set:tracks.ProtoFigures.add_tracks)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tracks

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tracks_2eproto
